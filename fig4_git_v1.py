# -*- coding: utf-8 -*-
"""
Time evolution of a mechanical mode with engineered two-phonon dissipation,
for different thermal occupations n_th of the mechanical bath.

For each n_th in [0, 0.5, 1, 2], we:
  1) Build the effective Liouvillian with one- and two-phonon processes.
  2) Evolve a thermal initial state up to a fixed final time t_final = 3 / Γ2_minus.
  3) Compute the Wigner function of the final state.
  4) Plot ONE Wigner panel (single figure) and save it to disk.

This version:
  * Uses x and p in the range [-6, 6].
  * Prints progress and the final average phonon number <n>.
"""

import numpy as np
import matplotlib.pyplot as plt
from qutip import *

# ============================================================
# 1. SYSTEM SETUP (dimension + physical parameters)
# ============================================================

# Hilbert space dimension for the mechanical mode
N = 100  # should be large enough to capture the cat state support

# --- Physical parameters (in Hz) ---

# Longitudinal coupling (σ_z (a + a†))
gz  = 2 * np.pi * 6e6         # Hz

# Ratio transverse / longitudinal coupling
r   = 0.1                     # dimensionless

# Transverse coupling (σ_x (a + a†))
gx  = r * gz                  # Hz

# Mechanical frequency
ωₘ  = 2 * np.pi * 100e6       # Hz

# Qubit frequency (chosen near 2 ω_m for two-phonon processes)
ωq  = 2 * ωₘ                  # Hz

# Qubit decay rate
κ   = 2 * np.pi * 100e3       # Hz

# Mechanical damping rate
γ   = 2 * np.pi * 15          # Hz

# Effective two-phonon coupling (from longitudinal × transverse / ω_m)
g = (gz * gx) / ωₘ            # Hz

# --- Drive parameters (effective two-phonon drive on the mechanics) ---

ϵ  = 10 * g                   # drive amplitude (chosen phenomenologically)
χ  = -2j * ϵ * g / κ          # complex two-phonon "squeezing" strength

# Thermal occupations of the mechanical bath we want to study
n_th_list = [0.0, 0.5, 1.0, 2.0]

# ============================================================
# 2. RATES THAT DO NOT DEPEND ON n_th
# ============================================================

# Half the qubit linewidth
x = κ / 2.0

# Detunings for single- and two-phonon processes
Δ1_minus = ωq - ωₘ
Δ1_plus  = ωq + ωₘ
Δ2_minus = ωq - 2 * ωₘ
Δ2_plus  = ωq + 2 * ωₘ

# Two-phonon processes (do not depend on n_th)
Re_S2_minus = x / (x**2 + Δ2_minus**2)
Γ2_minus = 2 * g**2 * Re_S2_minus      # "cooling" two-phonon rate

Re_S2_plus = x / (x**2 + Δ2_plus**2)
Γ2_plus = 2 * g**2 * Re_S2_plus        # "heating" two-phonon rate

# Imaginary parts for Kerr shift
Im_S2_minus = -Δ2_minus / (x**2 + Δ2_minus**2)
Im_S2_plus  = -Δ2_plus / (x**2 + Δ2_plus**2)

# Kerr nonlinearity generated by the same virtual processes
δ_k = g**2 * (Im_S2_minus + Im_S2_plus)   # Hz

# ============================================================
# 3. TIME GRID (common to all n_th)
# ============================================================

# We evolve up to t_final = 3 / Γ2_minus
tlist  = np.linspace(0, 3, 61) / Γ2_minus
t_final = tlist[-1]

print("===================================================")
print("Using final time t_final = 3 / Γ2_minus")
print("t_final [s] =", t_final)
print("===================================================\n")

# ============================================================
# 4. OPERATORS AND HAMILTONIAN (independent of n_th)
# ============================================================

# Annihilation operator of the mechanical mode
a  = destroy(N)
ad = a.dag()

# Number operator
n_op = ad * a

# Effective Hamiltonian for the mechanics
#   H = χ* a†² + χ a² + δ_k (a† a)²
H = χ.conjugate() * ad**2 + χ * a**2 + δ_k * (ad * a)**2

# QuTiP solver options
options = Options(nsteps=100000)

# ============================================================
# 5. WIGNER GRID (x and p both from -6 to +6)
# ============================================================

xvec = np.linspace(-6, 6, 600)   # x-grid
# p-grid is implicitly the same as xvec in qutip.wigner

# ============================================================
# 6. LOOP OVER THERMAL OCCUPATIONS n_th
# ============================================================

for idx, n_th in enumerate(n_th_list):
    print("---------------------------------------------------")
    print(f"Starting simulation for n_th = {n_th} "
          f"({idx+1}/{len(n_th_list)})")
    print("---------------------------------------------------")

    # -----------------------------------------------
    # 6.1 Single-phonon rates for this n_th
    # -----------------------------------------------

    # Real part of S_1(Δ1_minus) (same for Γ1_minus and Γ1_plus here)
    Re_S1_minus = x / (x**2 + Δ1_minus**2)

    # Qubit-induced single-phonon "cooling" rate
    Γ1_minus = 2 * gx**2 * Re_S1_minus

    # Total single-phonon cooling rate (intrinsic + qubit-induced)
    Γ_minus = (n_th + 1) * γ + Γ1_minus

    # Qubit-induced single-phonon "heating" rate
    Re_S1_plus = x / (x**2 + Δ1_minus**2)
    Γ1_plus = 2 * gx**2 * Re_S1_plus

    # Total single-phonon heating rate (intrinsic + qubit-induced)
    Γ_plus = n_th * γ + Γ1_plus

    print(f"Γ_minus (cooling) = {Γ_minus:.3e} Hz")
    print(f"Γ_plus  (heating) = {Γ_plus:.3e} Hz")
    print(f"Γ2_minus (two-phonon cooling) = {Γ2_minus:.3e} Hz")
    print(f"Γ2_plus  (two-phonon heating) = {Γ2_plus:.3e} Hz")

    # -----------------------------------------------
    # 6.2 Dissipators for this n_th
    # -----------------------------------------------

    dissipators = [
        Γ_minus  * lindblad_dissipator(a),      # single-phonon loss
        Γ_plus   * lindblad_dissipator(ad),     # single-phonon gain
        Γ2_minus * lindblad_dissipator(a**2),   # two-phonon loss
        Γ2_plus  * lindblad_dissipator(ad**2),  # two-phonon gain
    ]

    # -----------------------------------------------
    # 6.3 Initial state and time evolution
    # -----------------------------------------------

    # Initial mechanical state: thermal state with occupation n_th
    ρ0 = thermal_dm(N, n_th)

    print("Running mesolve up to t_final ...")
    result = mesolve(H, ρ0, tlist, dissipators, [], options=options)
    print("... mesolve finished.\n")

    # Final state at t_final
    ρ_final = result.states[-1]

    # Average phonon number <n> at final time
    n_avg = expect(n_op, ρ_final)
    print(f"Average phonon number at t_final for n_th = {n_th}: "
          f"<n> = {n_avg:.3f}\n")

    # -----------------------------------------------
    # 6.4 Wigner function at t_final and plotting
    # -----------------------------------------------

    print("Computing Wigner function on grid [-6, 6] × [-6, 6] ...")
    W = wigner(ρ_final, xvec, xvec)
    print("... Wigner function computed.\n")

    # Create ONE figure (single panel) for this n_th
    fig, ax = plt.subplots(figsize=(5, 4), dpi=600)

    # Symmetric color limits so that positive/negative lobes are comparable
    vmax = np.max(np.abs(W))
    vmin = -vmax

    im = ax.imshow(
        W,
        extent=[-6, 6, -6, 6],   # x and p ranges
        origin='lower',
        cmap='RdBu_r',
        vmin=vmin,
        vmax=vmax
    )

    # Axis labels and ticks
    ax.set_xlabel(r'$x$', fontsize=26)
    ax.set_ylabel(r'$p$', fontsize=26)
    ax.set_xticks([-6, 0, 6])
    ax.set_yticks([-6, 0, 6])
    ax.tick_params(axis='both', labelsize=18)

    # Colorbar with 5 ticks and 1-digit precision
    cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
    ticks = np.linspace(vmin, vmax, 5)
    cbar.set_ticks(ticks)
    cbar.ax.set_yticklabels([f"{tick:.1f}" for tick in ticks])
    cbar.ax.tick_params(labelsize=14)

    # ---- FIX: unique filename for each n_th ----
    nth_str = str(n_th).replace('.', 'p')   # e.g. 0.5 -> "0p5"
    fname = f"wigner_nth_{nth_str}.pdf"

    # Save figure to disk (one file per n_th)
    fig.savefig(fname, bbox_inches='tight')
    print(f"Wigner plot saved to: {fname}\n")

    # Show on screen (comment out if running non-interactively)
    plt.show()

print("All simulations completed.")
